// SCCPM.h: interface for the SCCPM class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "CPM.h"
#include "Trellis_Encoder.h"
#include "Interleaver.h"
#include "SISO_Decoder.h"
#ifdef CTOPCOM
#include "ctopcom.h"
#endif
/*! \file
\brief Declaration of class SCCPM_Encoder and SCCPM_Decoder
  */

/*! \ingroup Modems
\brief Generic binary Serial Concatenated Continuous Phase Modulation Encoder


A serially concatenated CPM scheme is built around three blocks: an external terminated 
Binary_Trellis_Encoder, an Interleaver on bits generated by the
binary encoder and an inner CPM_Modulator.


The user can specify through the method SetParameters() the trellis of the outer encoder, the interleaver and the
inner CPM modulator.  The two constituent encoders works in terminated mode so that the whole SCCPM encoder is a block
encoder.


A tic of the Run() method accepts a block of \f$K\f$ information bits and 
produces a block of \f$Nn_s\f$ complex samples with
constant envelope, where \f$n_s\f$ is the number of sample per waveform of generated by the inner 
CPM_Modulator.

For an example of its use see e.g. the test program "test_SCCPM.cpp".

\author Guido Montorsi

*/
class SCCPM_Encoder  
{
public:
	SCCPM_Encoder();
	virtual ~SCCPM_Encoder();

	//! Set the main parameters 
	void SetParameters(Trellis_Encoder* outer,	//!< Trellis outer encoder.
		const Interleaver*  interleaver,		//!< Interleaver.
		CPM_Modulator* inner					//!< Inner CPM modulator.
		);	
	
	//! Simulation method 
	void Run(const int tics,			//!< Number of encoded blocks
		const int* inp,					//!< Input bits
		double* out						//!< Output complex samples.
		);	

#ifdef CTOPCOM
	//! Overload of Run with complex signals
	void Run(const int tics,	//!< Number of encoded blocks
		 const int* inp,		//!< Input bits
		 cmplx* out				//!< Complex Output contellation points
		 )
	{
	Run(tics,inp,(double*) out);
	return;
	}
#endif

	int K;			//!< Input bits.
	int I;			//!< Interleaver length.
	int N;			//!< Output signals

	friend class SCCPM_Decoder;
private:
	Trellis_Encoder *outer;
	CPM_Modulator   *inner;
	const int* perm;
	int* buff;
};


/*! \ingroup Modems
\brief Generic binary Serial Concatenated Continuous Phase Modulation Decoder.

The SCCPM_Decoder is associated to the correspondent SCCPM_Encoder.

Through the method SetParameters the user specifies
- A pointer to the correspondent SCCPM_Encoder that describes the code structure
- The number of filters in the front-end used by the CPM_Demodulator
- The number of iterations \f$n_I\f$ of the decoder
- The size of updating and training window \f$T_W\f$ and \f$U_W\f$ of the embedded SISO decoders. 
(Optional, default to automatic computation)
- The scaling factor \f$f\f$  of the input quantized LLR. (Optional, default to 8, which gives
    ideal performances)


Optionally, with the method SetStop() the user can activate or deactivate the stopping rule of the decoder.

The Run() method takes as input the complex samples received from the channel. The first block, which is a
CPM_Demodulator, produces the LLRs on CPM waveforms that are then stored in a
buffer.
The following block is an iterative SCCC decoder that uses as inner code the trellis embedded in the CPM scheme. 
Note however that the inner SISO uses as inputs the LLRs of the \f$PM^L\f$ CPM waveforms that 
are associated to each trellis step of the CPM encoder.

For an example of its use see e.g. the test program "test_SCCPM.cpp".

\author Guido Montorsi

*/
class SCCPM_Decoder
{
public:
	SCCPM_Decoder();
	virtual ~SCCPM_Decoder();
	//! Set the main block parameyers
	void SetParameters(const SCCPM_Encoder* e,//!< Reference encoder
					  const int nfilters,	  //!< Number of filters in the front-end
					  const int nini,		  //!< Number of trellis steps for initialization
					  const int ngroup,		  //!< Number of trellis steps for grouped decisions
					  const int niter,		  //!< Number of iterations
					  const double factor=8.  //!< Factor for quantization of LLR
					  );

	void TuneParameters(const int niterin);
		void Run(const int tics,					//!< Number of encoded blocks
		const double* inp,					//!< Input bits
		int* out						//!< Output bits
		);	

#ifdef CTOPCOM
	//! Overload of Run with complex signals
	void Run(const int tics,	//!< Number of decoded blocks
		 const cmplx* inp,		//!< Input received complex samples
		 int* out				//!< output bits
		 )
	{
	Run(tics,(double*) inp,out);
	return;
	}
#endif

	//! Turn on or off the stopping rule in the iterative decoder
	void SetStop(const bool stopin=true){stop=stopin;}

	CPM_Demodulator *dem;	//!< The CPM demodulator.
	SISO_Decoder * iSISO;	//!< The inner SISO processor.
	SISO_Decoder * oSISO;	//!< The outer SISO processor.

private:
	const SCCPM_Encoder* refcod;
	int niter;
	int *llr;		// Temporary llr
	int *ext1;		// Temporary llr
	int *ext2;		// Temporary llr
	int nti;		// Number of trellis steps inner
	int nto;		// Number of trellis steps outer
	int nsymbols;
	bool stop;
};
